(self.webpackChunkdp_demo=self.webpackChunkdp_demo||[]).push([[553],{3044:(s,n,a)=>{"use strict";a.d(n,{Z:()=>p});var l=a(3645),t=a.n(l)()((function(s){return s[1]}));t.push([s.id,"/*\n\ngithub.com style (c) Vasily Polovnyov <vast@whiteants.net>\n\n*/\n\n.hljs {\n  display: block;\n  overflow-x: auto;\n  padding: 0.5em;\n  color: #333;\n  background: #f8f8f8;\n}\n\n.hljs-comment,\n.hljs-quote {\n  color: #998;\n  font-style: italic;\n}\n\n.hljs-keyword,\n.hljs-selector-tag,\n.hljs-subst {\n  color: #333;\n  font-weight: bold;\n}\n\n.hljs-number,\n.hljs-literal,\n.hljs-variable,\n.hljs-template-variable,\n.hljs-tag .hljs-attr {\n  color: #008080;\n}\n\n.hljs-string,\n.hljs-doctag {\n  color: #d14;\n}\n\n.hljs-title,\n.hljs-section,\n.hljs-selector-id {\n  color: #900;\n  font-weight: bold;\n}\n\n.hljs-subst {\n  font-weight: normal;\n}\n\n.hljs-type,\n.hljs-class .hljs-title {\n  color: #458;\n  font-weight: bold;\n}\n\n.hljs-tag,\n.hljs-name,\n.hljs-attribute {\n  color: #000080;\n  font-weight: normal;\n}\n\n.hljs-regexp,\n.hljs-link {\n  color: #009926;\n}\n\n.hljs-symbol,\n.hljs-bullet {\n  color: #990073;\n}\n\n.hljs-built_in,\n.hljs-builtin-name {\n  color: #0086b3;\n}\n\n.hljs-meta {\n  color: #999;\n  font-weight: bold;\n}\n\n.hljs-deletion {\n  background: #fdd;\n}\n\n.hljs-addition {\n  background: #dfd;\n}\n\n.hljs-emphasis {\n  font-style: italic;\n}\n\n.hljs-strong {\n  font-weight: bold;\n}\n",""]);const p=t},9153:(s,n,a)=>{"use strict";a.d(n,{Z:()=>l});const l='<h1>从递推开始说起</h1> <h2>从递归到递推</h2> <p>在解题时，我们经常可以遇到一类问题，问题的解可以表达成一种离散函数，但从问题本身不能直接得出函数的通项公式，只能用递归定义的方法来定义。</p> <p><strong>例题</strong>：兔子问题：有人在第一个月买入一对幼兔，从第三个月开始每个月都生一对兔子，小兔子出生后的第三个月开始也每个月生一对兔子，假如兔子都不死，问第 N 个月的时候总共有多少对兔子？</p> <p>上个月刚出生的兔子在本月不生兔子，其它兔子都在本月生一对新兔子，因此本月的兔子总数总是等于上个月的总兔子，加上上上个月的总兔子数（等于本月新出生的兔子数）。写作公式如下：</p> <p class="latex">F(n)=\\begin{cases} 0 &amp;n = 0\\\\ 1 &amp;n = 1\\\\ F(n-1)+F(n-2) &amp;n \\ge 2\\\\ \\end{cases} </p> <p>这个公式就是著名的斐波那契数列。对于给定<span class="latex">n</span>，求解<span class="latex">F(n)</span>。因为<span class="latex">F(n)</span>的数值比较大，答案需要对 <span class="latex">10^9+7</span> 取模。</p> <blockquote> <p>练一练？<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">LeetCode - 剑指 Offer 10- I. 斐波那契数列</a></p> </blockquote> <p><strong>解析</strong> 我们可以看出上面的函数定义就是一个“递归定义”。</p> <blockquote> <p>递归定义至少由两部分组成：</p> <ul> <li>基本情况：对于一些基本情况，直接定义该函数的值。</li> <li>归纳定义(递推公式)：对于未定义的情况，可以使用已定义的部分来定义。</li> </ul> <p>因此上述函数中，最先定义了 0 和 1，然后就可以使用归纳定义来定义出 2、3……直至 n 为所有自然数时的函数值</p> </blockquote> <p>对于递归定义的函数，我们总是可以将它直接翻译成递归算法的程序代码。</p> <pre><code class="language-js">function fib(n) {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n &gt;= 2) {\n    return (fib(n - 1) + fib(n - 2)) % 1000000007;\n  }\n}\n</code></pre> <blockquote> <p>和递归定义一样，递归算法通常也至少包含两个部分：</p> <ul> <li>终结条件：对应递归定义的“基本情况”，可以直接求解的问题</li> <li>递归过程：对应递归定义的“归纳定义”，需要通过递归调用自身来求解。</li> </ul> </blockquote> <div class="question"> <p><strong>思考</strong> 上述递归算法的时间复杂度是多少呢？</p> <ul> <li><div class="question-choice" data-wrong></div> <span class="latex">A. \\Theta(n)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">B. \\Theta(n^2)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">C. \\Theta(2^n)</span></li> <li><div class="question-choice" data-right></div> <span class="latex">D. \\Theta((\\frac{1+\\sqrt5}{2})^n)</span></li> </ul> <blockquote> <p><span class="latex">\\Theta</span>符号是什么意思？看<a href="/404.html">这里</a>。</p> </blockquote> <div class="answer"> <blockquote> <p>正确答案是<span class="latex">D</span>，因为可以看出函数的调用次数是和<span class="latex">F(n)</span>同样规模的数字。</p> <p>通过查找资料我们可以知道<span class="latex">F(n)=\\frac{1}{\\sqrt5}[(\\frac{1+\\sqrt5}{2})^n-(\\frac{1-\\sqrt5}{2})^n]</span></p> <p>其中<span class="latex">|(\\frac{1-\\sqrt5}{2})^n|&lt;1</span>，在考虑时间复杂度时，我们可以忽略掉这一项和前面的常系数<span class="latex">\\frac{1}{\\sqrt5}</span>。</p> <p>A 选项和 B 选项都不是指数复杂度，所以一定不对。</p> <p>C 选项为什么不对？看<a href="/404.html">这里</a>。</p> </blockquote> </div> </div> <p>上述递归算法的时间复杂度是一个指数复杂度，这意味着在 n 很大的时候，计算所消耗的时间也会快速增长。究其原因，是因为该算法其实有大量重复的计算：</p> <pre><code class="language-mermaid">graph TD\n  f5[&quot;F(5)&quot;]\n  f5 --&gt; f41[&quot;F(4)&quot;] &amp; f31[&quot;F(3)&quot;]\n  f41 --&gt; f32[&quot;F(3)&quot;] &amp; f22[&quot;F(2)&quot;]\n  f31 --&gt; f23[&quot;F(2)&quot;] &amp; f13[&quot;F(1)&quot;]\n  f32 --&gt; f24[&quot;F(2)&quot;] &amp; f14[&quot;F(1)&quot;]\n  f22 --&gt; f15[&quot;F(1)&quot;] &amp; f05[&quot;F(0)&quot;]\n  f23 --&gt; f16[&quot;F(1)&quot;] &amp; f06[&quot;F(0)&quot;]\n  f24 --&gt; f17[&quot;F(1)&quot;] &amp; f07[&quot;F(0)&quot;]\n\n  classDef f4 fill:#519aff\n  classDef f3 fill:#ffa108\n  classDef f2 fill:#ff5400\n  classDef f1 fill:#b086e1\n  classDef f0 fill:#5ac882\n\n  class f41 f4;\n  class f31,f32 f3;\n  class f22,f23,f24 f2;\n  class f13,f14,f15,f16,f17 f1;\n  class f05,f06,f07 f0;\n</code></pre> <p>观察整个调用过程，我们可以看出计算<span class="latex">F(5)</span>的过程中，我们总计计算了两次<span class="latex">F(3)</span>，三次<span class="latex">F(2)</span>，五次<span class="latex">F(1)</span>，三次<span class="latex">F(0)</span>。但是<span class="latex">F(n)</span>是一个纯函数，意味着<span class="latex">n</span>相同时， <span class="latex">F(n)</span>的值其实是确定的，因此我们可以采取递推方法来更有效的计算<span class="latex">F(n)</span>：</p> <pre><code class="language-js">function fib(n) {\n  let a = [];\n  // 初始已知值\n  a[0] = 0;\n  a[1] = 1;\n\n  for (let i = 2; i &lt;= n; i++) {\n    // 递推计算\n    a[i] = (a[i - 1] + a[i - 2]) % 1000000007;\n  }\n  return a[n];\n}\n</code></pre> <p>这就是递推算法的典型实现。我们可以<strong>采用数组记录已知的所有序列，并按照顺序陆续计算出新的序列，直到待求解的值被求解出为止</strong>。</p> <blockquote> <p>除了采用递推外，在递归的基础上加以缓存优化来避免大量重复计算也是非常有效的避免重复计算的方法。如果递归公式复杂，改造时间紧张，不妨也可以考虑这种方法。</p> </blockquote> <div class="question"> <p><strong>思考</strong>：上述递推算法的时间复杂度是多少呢？</p> <ul> <li><div class="question-choice" data-right></div> <span class="latex">A. \\Theta(n)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">B. \\Theta(n^2)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">C. \\Theta(2^n)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">D. \\Theta((\\frac{1+\\sqrt5}{2})^n)</span></li> </ul> <div class="answer"> <blockquote> <p>正确答案是<span class="latex">A</span>，该算法没有包含递归，循环进行了<span class="latex">n-1</span>次，与 n 线性相关。时间复杂度记作<span class="latex">\\Theta(n)</span>。</p> </blockquote> </div> </div> <h3>滚动数组</h3> <p>我们可以注意到，上述算法中，对于计算下一个值，有用的仅仅是最近的 2 个值，因此之前的值没有必要长期保存。因此我们可以采用不断替换最近 2 个值的方法，有效的降低问题的空间复杂度：</p> <pre><code class="language-js">function fib(n) {\n  if (n === 0) {\n    return 0;\n  }\n  // 记录最近的两个值\n  let a = 0,\n    b = 1;\n  for (let i = 2; i &lt;= n; i++) {\n    // 下一个值\n    const next = (a + b) % 1000000007;\n    // 滚动\n    a = b;\n    b = next;\n  }\n  return b;\n}\n</code></pre> <div class="question"> <p><strong>思考</strong>：上述滚动数组实现递推算法的时间复杂度是多少呢？</p> <ul> <li><div class="question-choice" data-wrong></div> <span class="latex">A. \\Theta(1)</span></li> <li><div class="question-choice" data-right></div> <span class="latex">B. \\Theta(n)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">C. \\Theta(n^2)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">D. \\Theta((\\frac{1+\\sqrt5}{2})^n)</span></li> </ul> <div class="answer"> <blockquote> <p>正确答案是<span class="latex">B</span>，尽管空间复杂度降低到了<span class="latex">\\Theta(1)</span>，但仍然循环了<span class="latex">n-2</span>次，时间复杂度仍为<span class="latex">\\Theta(n)</span>。</p> </blockquote> </div> </div> <h3>补充知识</h3> <p>求解递归定义的函数，递推也不是唯一的方法。</p> <p>上述斐波那契问题就可以采用分治法或矩阵求幂的方法达到<span class="latex">\\Theta(\\text{lg}n)</span>的时间复杂度。想深入了解？看<a href="/404.html">这里</a>。</p> <p>另外如果不是为了求余数，而是求近似值，采用组合数学中的母函数方法也可以得到它的通项公式：<span class="latex">F(n)=\\frac{1}{\\sqrt5}[(\\frac{1+\\sqrt5}{2})^n-(\\frac{1-\\sqrt5}{2})^n]</span>。想深入了解？看<a href="/404.html">这里</a>。</p> <h2>应用题</h2> <p>在解决实际问题时，递推算法的设计过程也通常分为以下三个步骤</p> <ol> <li>抽象问题，定义函数，明确参数和值的含义</li> <li>列出可直接求解的函数值（终结条件）</li> <li>列出递推公式</li> </ol> <div class="question"> <p><strong>例题</strong> 走台阶问题：一段楼梯共有 N 级台阶，每次可以走一级、走两级、或者走三级，请问总计有多少种不同的走法？</p> <div class="answer"> <p><strong>解析</strong> 设 F(n)为走到第 n 级台阶的总方法数，那么当<span class="latex">n&gt;3</span>时所有的方法中最后一步只能分为三种情况：</p> <ul> <li>最后一步走了 1 级台阶：等于上一级台阶的总方法数<span class="latex">F(n-1)</span>。</li> <li>最后一步走了 2 级台阶：等于上上级台阶的总方法数<span class="latex">F(n-2)</span>。</li> <li>最后一步走了 3 级台阶：等于上上上级台阶的总方法数<span class="latex">F(n-3)</span>。</li> </ul> <p>运用加法原理把所有的情况加起来，就有：</p> <p class="latex">F(n)=\\begin{cases} 1&amp;\\text{n = 1}\\\\ F(n-1)+1 = 2&amp;\\text{n = 2}\\\\ F(n-1)+F(n-2)+1 = 4&amp;\\text{n = 3}\\\\ F(n-1)+F(n-2)+F(n-3)&amp;\\text{n &gt; 3}\\\\ \\end{cases} </p> <p>我们也可规定<span class="latex">F(0)=1</span>(从起点开始)，<span class="latex">F(-1)=F(-2)=0</span>(不合法的参数，意味着没有任何方法可以从起点之前开始)，简化函数定义如下：</p> <p class="latex">F(n)=\\begin{cases} 0&amp;\\text{n &lt; 0}\\\\ 1&amp;\\text{n = 0}\\\\ F(n-1)+F(n-2)+F(n-3)&amp;\\text{n &gt; 0}\\\\ \\end{cases} </p> <p>采用递推方法求得<span class="latex">F(N)</span>即为问题的解。</p> <blockquote> <p>在将上述递归函数转化为递推实现时，没有必要求解不合法的值，可以在取<span class="latex">F(n)</span>时，如果参数不合法，则直接跳过该项。</p> </blockquote> </div> </div> <div class="question"> <p><strong>例题</strong> 约瑟夫环问题：N 个人排成一圈，从第一个人开始按 1、2、3……K 的顺序循环报数，每次报到 K 的人立即出列，请问最后剩下的人是最开始队伍中的第几个人？</p> <div class="answer"> <p><strong>解析</strong> 设<span class="latex">F(n)</span>为<span class="latex">n</span>个人的情况下最后剩下人的编号。可以注意到，第一轮报数之后，第一个人出列，正好剩下<span class="latex">n-1</span>个人。假设<span class="latex">F(n-1)</span>在此时的编号为<span class="latex">x</span>，那么倒退回第一轮，相当于<span class="latex">x</span>的序号往后恰好推迟了<span class="latex">K</span>（如果<span class="latex">x+K</span>超过 n，需要对 n 取余)。为了方便取余，我们规定<span class="latex">F(n)</span>的编号为<span class="latex">0</span>到<span class="latex">n-1</span>，最后再加回<span class="latex">1</span>。</p> <p class="latex">N=8,K=3\\\\ \\text{假如已知F}(7)=3\\\\ \\text{第一轮报数后：}\\\\ 5,6,-,0,1,2,\\textcolor{red}3,4\\\\ \\text{第一轮报数前：}\\\\ \\textcolor{green}0,\\textcolor{green}1,\\textcolor{green}2,3,4,5,\\textcolor{red}6,7\\\\ </p> <p>所以可以写出公式：</p> <p class="latex">F(n)=\\begin{cases} 0&amp;\\text(n=1)\\\\ (F(n-1)+K)\\ mod\\ n&amp;\\text(n&gt;1)\\\\ \\end{cases} </p> <p>采用递推方法求得<span class="latex">F(N)</span>，然后<span class="latex">F(N)+1</span>即为问题的解。</p> <blockquote> <p>约瑟夫环还是练习数据结构的好问题。想看更完整的介绍、以及了解约瑟夫环更低复杂度的计算方法？可以看：<a href="https://www.bilibili.com/video/BV1hK4y1s7Ln?p=2">这里</a></p> </blockquote> </div> </div> <div class="question"> <p><strong>例题</strong> 路线统计：在一个<span class="latex">N\\times M</span>地图中，每一个格子可能是障碍物或可通行的，只允许向右和向下移动，问从左上角到右下角，共计有多少种不同的走法？</p> <pre><code>4 4\n0 0 0 0\n1 0 0 0\n0 0 1 0\n0 0 0 0\n</code></pre> <div class="answer"> <p><strong>解析</strong> 因为只允许向右和向下移动，所以我们可以按照顺序递推求解：每个可通行的格子，其所有走法可能来自于上方或左方。我们用<span class="latex">G(x,y)</span>表示每个格子是否可通行，<span class="latex">F(x,y)</span>表示以每个格子为终点的走法总数，那么有：</p> <p class="latex">F(x,y)=\\begin{cases} 0&amp;\\text(x&lt;0\\lor y&lt;0)&amp; \\text{边界外}\\\\ 0&amp;\\text(G(x,y)=1)&amp; \\text{不可通行}\\\\ 1&amp;\\text(x=y=0 &amp; \\text{起点}\\\\ F(x-1,y)+F(x,y-1)&amp;\\text(else)\\\\ \\end{cases} </p> <p>最后求解<span class="latex">F(N-1,M-1)</span>即为问题的解。</p> <blockquote> <p>需要特别注意：如果状态不能按顺序归纳，（譬如可以上下左右四个方向移动），那么是不能用递推方法求解的。</p> </blockquote> </div> </div> <h3>寻找间接递推</h3> <p>有些问题本身没法直接描述成一个可以递推的函数，因此我们需要另外建立一个辅助的函数，通过它间接求出问题的解。</p> <div class="question"> <p><strong>例题</strong> 涂色问题：用<span class="latex">K</span>种不同的颜色涂<span class="latex">N</span>边形的<span class="latex">N</span>个顶点，要求每点染一种颜色，相邻的两点不能是相同的颜色，请问总计有多少种染法？</p> <div class="answer"> <p><strong>解析 1</strong> 相邻的两点不能是相同的颜色，因此第一个点有<span class="latex">K</span>种涂法，后续每个点（与之前不同）有<span class="latex">K-1</span>种，但麻烦的问题在于最后一个顶点也要求和第一个顶点涂法不同，但我们不能确定最后一个顶点是<span class="latex">K-1</span>种还是<span class="latex">K-2</span>种涂法。</p> <p>但是我们可以迂回解决这个问题：如果不限制最后一个点和第一个顶点是否相同颜色，多出的所有组合数，都是最后一个点和第一个顶点颜色相同的情况，并且该颜色和第二个点、倒数第二个点均不同。如果我们将这两个颜色相同的点合并为一个点，那么恰好等同于<span class="latex">N-1</span>边形所有符合要求的所有组合。</p> <p><img src="./images/color.png" alt="示例"></p> <p>设<span class="latex">F(N)</span>为题目求解的涂法数量，<span class="latex">G(N)</span>为不限制最后一个点和第一个点是否相同的涂法数量，那么有：</p> <p class="latex">G(n)=\\begin{cases} K&amp;\\text(n=1)\\\\ G(n-1)*(K-1)&amp;\\text(n&gt;1)\\\\ \\end{cases}\\\\ F(n)=\\begin{cases} G(n)&amp;\\text(n\\le 2)\\\\ G(n)-F(n-1)&amp;\\text(n&gt;2) \\end{cases} </p> <p>虽然<span class="latex">G(n)</span>是一个等比数列，在数学上很容易写出一个通项公式<span class="latex">K*(K-1)^{n-1}</span>，但是在算法实现上，反而递推的版本更容易达到整体<span class="latex">\\Theta (n)</span>的时间复杂度。</p> <p><strong>解析 2</strong> 还可以换一种方法来思考，第一个点有<span class="latex">K</span>种涂法，之后按顺序涂每个点，都可能有两种情况：与第一个点颜色不同，或与第一个点颜色相同。我们可设与第一个点颜色不同的组合数为 F(n)，与第一个点颜色相同的组合数为 G(n)</p> <ul> <li>当前点与第一个点颜色相同时，上一个点必定与当前点颜色不同，因此也与第一个点颜色不同。并且当前点的颜色唯一确定。</li> <li>当前点与第一个点颜色不同时，上一个点可以与第一个点相同（这个点有 K-1 种涂法），也可以与第一个点不同（这个点有 K-2 种涂法，因为要和第一个点不同，和上一个点也不同）</li> <li>第一个点必然和第一个点颜色相同，并且总计有 K 种不同的涂法。</li> </ul> <p>写成公式如下：</p> <p class="latex">F(n)=\\begin{cases} 0 &amp; n=1 \\\\ G(n-1)*(K-1) + F(n-1)*(K-2)&amp; n&gt;1\\\\ \\end{cases}\\\\ G(n)=\\begin{cases} K &amp; n=1 \\\\ F(n-1) &amp; n&gt;1\\\\ \\end{cases}\\\\ </p> <p>另外我们要求最后一个点与第一个点颜色不同，所以<span class="latex">F(N)</span>即为问题的解</p> <p>我们还可以将<span class="latex">G(n)</span>代入<span class="latex">F(n)</span>继续化简公式：</p> <p class="latex">F(n)=\\begin{cases} 0 &amp; n=1 \\\\ K*(K-1) &amp; n=2 \\\\ F(n-2)*(K-1) + F(n-1)*(K-2)&amp; n&gt;1\\\\ \\end{cases}\\\\ </p> <p>这个公式不但可以应用递推法求解，也可以应用矩阵法或母函数法进行求解。</p> </div> </div> <h3>寻找辅助参数</h3> <p>有些问题题目中没有包含所有的参数，我们需要为函数补充一个隐含的参数才能完成递推过程</p> <div class="question"> <p><strong>例题</strong> 整数划分：将正整数<span class="latex">N</span>划分成至少两个整数的和。求解所有本质不同的划分的组合总数，顺序不同的解只能算作一个解。</p> <p>例如<span class="latex">N=4</span>时有 4 种划分：</p> <p class="latex">4=1+1+1+1\\\\ 4=1+1+2\\\\ 4=1+3\\\\ 4=2+2\\\\ </p> <div class="answer"> <p><strong>解析</strong> 该题显然可以使用深度优先求解，但是复杂度至少为指数级。要求解的是本质不同的组合总数，顺序不同的解只能算作一次，换句话说，必须保证划分的顺序。这样我们无法直接对<span class="latex">F(n)</span>进行递推，因为我们不知道之前的解中最大的一个数是多少。但我们可以引入新的参数<span class="latex">j</span>：</p> <p>定义<span class="latex">F(n,j)</span>表示对 n 的所有划分中，<strong>最大一份恰好为<span class="latex">j</span>的方案</strong>，那么剩下的部分就可以采用所有<span class="latex">\\le j</span>的划分，然后就可以写出递推式：</p> <p class="latex">F(n,j)=\\begin{cases} 1&amp;\\text{n=j}\\\\ 0&amp;\\text{n&lt;j}\\\\ \\sum\\limits_{i=1}^{j}f(n-j, i)&amp;\\text{n&gt;j}\\\\ \\end{cases} </p> <p>注意我们在这里没有排除掉只划分成一份的方案，但我们最终求解问题时需要排除掉不划分的方案，所以<span class="latex">\\sum_{i=1}^{n-1}f(n,i)</span>就是问题的解。</p> <blockquote> <p>如果<span class="latex">F(n,i)</span>排除了只划分成一份的方案，反而不利于递推式的书写。</p> </blockquote> </div> </div> <div class="question"> <p><strong>例题</strong> 括号生成：有 N 对括号，问有多少种有效的括号组合？有效是指每对括号都是左括号在左、右括号在右。</p> <pre><code>N=3时有5种组合：\n((()))\n(()())\n(())()\n()(())\n()()()\n</code></pre> <div class="answer"> <p><strong>解析 1</strong> 我们可以看出，合法组合的任意前缀，都有左括号数量&gt;=右括号数量（右括号一旦多余左括号，就不能完成匹配）。反之，如果一个组合的任意前缀都有左括号数量&gt;=右括号数量，那么该组合必定是合法的。</p> <p>因此我们可以规定<span class="latex">F(i,j)</span>为 i 个左括号和 j 个右括号组成的所有合法组合总数，分为三种情况讨论：</p> <ul> <li><span class="latex">i&lt;j \\lor j&lt;0</span>时，一定不合法。</li> <li><span class="latex">i=0 \\land j=0</span>时，已经填完所有的括号，因此记作一种合法组合。</li> <li>其余情况，最后位置可以选择左括号或右括号。选择之后有可能导致剩下的数目不合法，此时<span class="latex">F(i-1,j)</span>或<span class="latex">F(i,j-1)</span>为 0，无需额外处理。</li> </ul> <p>列成公式：</p> <p class="latex">F(i,j)=\\begin{cases} 0&amp;(i&lt;j \\lor j&lt;0)\\\\ 1&amp;(i=0 \\land j=0)\\\\ F(i-1,j)+F(i,j-1) &amp;(else)\\\\ \\end{cases} </p> <p><strong>解析 2</strong> 考虑第一个左括号，及与其匹配的右括号，剩下的括号，要么在这对括号内部，要么在这对括号右侧。</p> <pre><code>[ (()) ]\n[ ()() ]\n[ () ] ()\n[] (())\n[] ()()\n</code></pre> <p>这时可采用分治法思想，将这对括号内部和右侧的所有组合都可以看做子问题。 当确定这两部分各自的括号数量时，两个子问题相互独立，因此可应用乘法原理。 当括号数量的分配形式不同时，一定得到不同的组合，因此可应用加法原理求出总的组合数。</p> <p>设<span class="latex">F(n)</span>为 n 对括号的所有合法组合总数，那么有：</p> <p class="latex">F(n)=\\begin{cases} 1&amp;(n=0)\\\\ \\sum\\limits_{i=0}^{n-1}F(i)*F(n-1-i)&amp;(n&gt;0) &amp; \\text{i表示第一部分的括号数量}\\\\ \\end{cases} </p> <blockquote> <p>一个递推问题可能有多种办法求解，通过对比不同方法的时间和空间复杂度，可以选择复杂度更低的方法</p> </blockquote> <blockquote> <p>关于括号组合问题的更多分析，可以看<a href="https://www.bilibili.com/video/BV1hK4y1s7Ln?p=1">这里</a>，通过问题的变形，还可以得到一个可以在<span class="latex">\\Theta(n)</span>时间求解的公式。这个组合数也被称作卡塔兰数</p> </blockquote> </div> </div> <h2>总结</h2> <p>递推类问题的解决方法共分为几步：</p> <ol> <li><strong>明确参数，定义函数</strong>：参数可能是问题本身的输入，也可能需要引入新的辅助参数。</li> <li><strong>逆推函数，列出递推公式</strong>：将一个未知状态的解用几个已知状态来描述。应用题常使用分治法。组合计数类问题常需要应用加法原理、乘法原理等。</li> <li><strong>确定可直接求解的基础函数值</strong>：包括“不合法情形”和“初始情形”等。</li> </ol> <p>另外必须满足以下条件：</p> <ol> <li><strong>参数必须能描述完整的问题状态</strong>。如果参数不能完整描述状态，就极易得出错误的递推公式。需要多做练习。</li> <li><strong>递推公式必须能按顺序求解</strong>：如果状态的变化路径中存在环，那么可能要应用一些搜索算法(如广度优先搜索、深度优先搜索、A*等)。如果不存在环，但不能按顺序归纳，那么有可能使用带缓存的递归来替代递推会使得编码更加容易。</li> <li><strong>参数取值范围必须有限，不涉及连续参数、无穷参数</strong>：如果参数的取值范围可能有无穷多个，不论是连续域、范围过大、参数可选无穷多种分数等情况，都必须先用数学方法将参数取值范围确定到有限个数之内才能应用递推算法。</li> </ol> '},587:(s,n,a)=>{"use strict";var l=a(3379),t=a.n(l),p=a(3044);t()(p.Z,{insert:"head",singleton:!1}),p.Z.locals},7361:(s,n,a)=>{"use strict";var l=a(4096),t=a(6695),p=a(9153);a(587),window.addEventListener("DOMContentLoaded",(function(){var s=document.createElement("article");s.className="markdown-body article",s.innerHTML=p.Z,document.body.appendChild(s),(0,l.dp)(),(0,l.HZ)(),(0,l.AA)(),(0,l.Bh)(),(0,t.T)()}))}},s=>{"use strict";s.O(0,[96],(()=>(7361,s(s.s=7361)))),s.O()}]);