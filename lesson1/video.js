(self.webpackChunkdp_demo=self.webpackChunkdp_demo||[]).push([[846],{7651:(a,n,e)=>{"use strict";e.d(n,{Z:()=>l});var s=e(3645),t=e.n(s)()((function(a){return a[1]}));t.push([a.id,"/*\nMonokai style - ported by Luigi Maselli - http://grigio.org\n*/\n\n.hljs {\n  display: block;\n  overflow-x: auto;\n  padding: 0.5em;\n  background: #272822;\n  color: #ddd;\n}\n\n.hljs-tag,\n.hljs-keyword,\n.hljs-selector-tag,\n.hljs-literal,\n.hljs-strong,\n.hljs-name {\n  color: #f92672;\n}\n\n.hljs-code {\n  color: #66d9ef;\n}\n\n.hljs-class .hljs-title {\n  color: white;\n}\n\n.hljs-attribute,\n.hljs-symbol,\n.hljs-regexp,\n.hljs-link {\n  color: #bf79db;\n}\n\n.hljs-string,\n.hljs-bullet,\n.hljs-subst,\n.hljs-title,\n.hljs-section,\n.hljs-emphasis,\n.hljs-type,\n.hljs-built_in,\n.hljs-builtin-name,\n.hljs-selector-attr,\n.hljs-selector-pseudo,\n.hljs-addition,\n.hljs-variable,\n.hljs-template-tag,\n.hljs-template-variable {\n  color: #a6e22e;\n}\n\n.hljs-comment,\n.hljs-quote,\n.hljs-deletion,\n.hljs-meta {\n  color: #75715e;\n}\n\n.hljs-keyword,\n.hljs-selector-tag,\n.hljs-literal,\n.hljs-doctag,\n.hljs-title,\n.hljs-section,\n.hljs-type,\n.hljs-selector-id {\n  font-weight: bold;\n}\n",""]);const l=t},9151:(a,n,e)=>{"use strict";e.d(n,{Z:()=>s});const s='<h2>动态规划精讲</h2> <aside class="notes"> 大家好，我是黑洞，我们这套动态规划精讲的课程系列将分成7课，由浅入深的讲解动态规划的原理、解题技巧、编码技巧等等。 这套课程也是我们尝试互动视频和互动阅读的首套课程，希望大家能够加入我们的解题十分钟粉丝群，可以通过首页链接或者本视频最后的二维码加群，关于课程提问以及有其它算法、数学方面想要学习的内容都可以加群讨论哈 </aside> <hr> <h2>从递推开始说起</h2> <aside class="notes"> 第一节课我们来聊一下递推。在解题时，我们经常可以遇到一类问题，问题的解可以表达成一种序列或者是离散函数，但从问题本身不能直接得出函数的通项公式，只能用递归定义的方法来定义。 </aside> <hr> <h2>兔子问题</h2> <p>有人在第一个月买入一对幼兔，从第三个月开始每个月都生一对兔子，小兔子出生后的第三个月开始也每个月生一对兔子，假如兔子都不死，问第 N 个月的时候总共有多少对兔子？</p> <aside class="notes"> 我们看一下这道题。 从题目可以看出，上个月刚出生的兔子在本月不生兔子，其它兔子都在本月生一对新兔子，因此本月的兔子总数总是等于上个月的总兔子，加上上上个月的总兔子数，也就是本月新出生的兔子数。 </aside> <hr> <p class="latex">F(n)=\\begin{cases} 0 &amp;n = 0\\\\ 1 &amp;n = 1\\\\ F(n-1)+F(n-2) &amp;n \\ge 2\\\\ \\end{cases} </p> <aside class="notes"> 写成公式大概就是这样的形式，F(0)=0,F(1)=1，n大于2的情况下，F(n)=F(n-1)+F(n-2)。 这个公式就是著名的斐波那契数列。下面我们就需要编程来解决，对于给定$n$，求解$F(n)$。 </aside> <hr> <p class="latex">F(n)=\\begin{cases} 0 &amp;n = 0\\\\ 1 &amp;n = 1\\\\ F(n-1)+F(n-2) &amp;n \\ge 2\\\\ \\end{cases} </p> <h2>递归定义</h2> <ul> <li>基本情况</li> <li>归纳定义(递推公式)</li> </ul> <aside class="notes"> 我们可以看出上面的函数定义就是一个“递归定义”。 递归定义至少由两部分组成： 基本情况：对于一些基本情况，直接定义该函数的值。 归纳定义(递推公式)：对于未定义的情况，可以使用已定义的部分来定义。 上述函数中，最先定义了0和1，然后就可以使用归纳定义来定义出2、3……直至n为所有自然数时的函数值 </aside> <hr> <p class="latex">F(n)=\\begin{cases} 0 &amp;n = 0\\\\ 1 &amp;n = 1\\\\ F(n-1)+F(n-2) &amp;n \\ge 2\\\\ \\end{cases} </p> <blockquote> <p>练一练？<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">LeetCode - 剑指 Offer 10- I. 斐波那契数列</a></p> </blockquote> <aside class="notes"> 在LeetCode上就有一道斐波那契的题目，因为$F(n)$的数值比较大，这道题答案需要对 $10^9+7$ 取模。 同学们可以先试着写一下看看。 </aside> <hr> <pre><code data-line-numbers="1-11|2-7|8-10|1-11" data-id="code" class="language-js">function fib(n) {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n &gt;= 2) {\n    return (fib(n - 1) + fib(n - 2)) % 1000000007;\n  }\n}\n</code></pre> <aside class="notes"> 对于递归定义的函数，我们总是可以将它直接翻译成递归算法的程序代码。 和递归定义一样，递归算法通常也至少包含两个部分： 终结条件：对应递归定义的“基本情况”，可以直接求解的问题 递归过程：对应递归定义的“归纳定义”，需要通过递归调用自身来求解。 </aside> <hr> <pre><code data-line-numbers="1-11" data-id="code" class="language-js">function fib(n) {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n &gt;= 2) {\n    return (fib(n - 1) + fib(n - 2)) % 1000000007;\n  }\n}\n</code></pre> <h4>该算法的时间复杂度是多少呢？</h4> <ul> <li><div class="question-choice" data-wrong></div> <span class="latex">A. \\Theta(n)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">B. \\Theta(n^2)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">C. \\Theta(2^n)</span></li> <li><div class="question-choice" data-right></div> <span class="latex">D. \\Theta((\\frac{1+\\sqrt5}{2})^n)</span></li> </ul> <blockquote> <p><span class="latex">\\Theta</span>符号是什么意思？看<a href="/404.html">这里</a>。</p> </blockquote> <aside class="notes"> 现在我们来思考一下，这个算法的时间复杂度是多少呢？ </aside> <hr> <pre><code data-line-numbers="1-11" data-id="code" class="language-js">function fib(n) {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n &gt;= 2) {\n    return (fib(n - 1) + fib(n - 2)) % 1000000007;\n  }\n}\n</code></pre> <div class="fragment" data-fragment-index="0"> <div class="r-stack"> <div class="fragment fade-out latex" data-fragment-index="4"> \\htmlData{class=fragment fade-out, fragment-index=1}{F(n)=} \\htmlData{class=fragment fade-out, fragment-index=2}{\\frac{1}{\\sqrt5}[} (\\frac{1+\\sqrt5}{2})^n \\htmlData{class=fragment fade-out, fragment-index=3}{-(\\frac{1-\\sqrt5}{2})^n} \\htmlData{class=fragment fade-out, fragment-index=2}{]} </div> <div class="fragment latex fade-in" data-fragment-index="4"> \\Theta( (\\frac{1+\\sqrt5}{2})^n ) </div> </div> </div> <blockquote> <p><span class="latex">\\Theta(2^n)</span>为什么不对呢？看<a href="/404.html">这里</a> </p> </blockquote> <aside class="notes"> 正确答案是$D$，因为可以看出函数的调用次数是和$F(n)$同样规模的数字。 通过母函数(或者查找资料)我们可以知道F(n)等于这样一个公式 在考虑时间复杂度时，我们可以忽略掉常系数$\\frac{1}{\\sqrt5}$。 后面的这一项底数的绝对值小于1，所以随着n增大，这一项的值也是收敛的。所以这一项也可以忽略掉。 为什么同为指数的2的N次方不对呢？同学们可以先思考下，然后点击课件中的链接了解。 </aside> <hr> <pre><code class="language-mermaid">graph TD\n  f5[&quot;F(5)&quot;]\n  fragment\n  f5 --&gt; f41[&quot;F(4)&quot;] &amp; f31[&quot;F(3)&quot;]\n  fragment\n  f41 --&gt; f32[&quot;F(3)&quot;] &amp; f22[&quot;F(2)&quot;]\n  f31 --&gt; f23[&quot;F(2)&quot;] &amp; f13[&quot;F(1)&quot;]\n  fragment\n  f32 --&gt; f24[&quot;F(2)&quot;] &amp; f14[&quot;F(1)&quot;]\n  f22 --&gt; f15[&quot;F(1)&quot;] &amp; f05[&quot;F(0)&quot;]\n  f23 --&gt; f16[&quot;F(1)&quot;] &amp; f06[&quot;F(0)&quot;]\n  fragment\n  f24 --&gt; f17[&quot;F(1)&quot;] &amp; f07[&quot;F(0)&quot;]\n\n  classDef f4 fill:#519aff\n  classDef f3 fill:#ffa108\n  classDef f2 fill:#ff5400\n  classDef f1 fill:#b086e1\n  classDef f0 fill:#5ac882\n\n  class f41 f4;\n  class f31,f32 f3;\n  class f22,f23,f24 f2;\n  class f13,f14,f15,f16,f17 f1;\n  class f05,f06,f07 f0;\n</code></pre> <aside class="notes"> 观察调用过程，计算F(5)时，需要先计算F(4)和F(3) 随后又计算了一次F(3)、两次F(2)、一次F(1) 再下一层又计算了一次F(2)、三次F(1)、两次F(0) 总共计算了两次F(3)、三次F(2)、五次F(1)、三次F(0)。但是F(n)是一个纯函数，意味着n相同时，F(n)的值其实是确定的，重复计算是没有必要的，因此我们可以采取递推方法来更有效的计算$F(n)$： </aside> <hr> <pre><code data-line-numbers="1-12|2-2|3-5|7-10|1-12" data-id="code1" class="language-js">function fib(n) {\n  let a = [];\n  // 初始已知值\n  a[0] = 0;\n  a[1] = 1;\n\n  for (let i = 2; i &lt;= n; i++) {\n    // 递推计算\n    a[i] = (a[i - 1] + a[i - 2]) % 1000000007;\n  }\n  return a[n];\n}\n</code></pre> <aside class="notes"> 这就是递推算法的典型实现。 我们可以采用数组记录已知的所有序列 并按照顺序陆续计算出新的序列，直到待求解的值被求解出为止。 除了采用递推外，在递归的基础上使用缓存优化来避免重复计算也是非常有效的降低时间复杂度的方法。如果递归公式复杂，改造时间紧张，不妨也可以考虑这种方法。 </aside> <hr> <pre><code data-line-numbers="1-12" data-id="code1" class="language-js">function fib(n) {\n  let a = [];\n  // 初始已知值\n  a[0] = 0;\n  a[1] = 1;\n\n  for (let i = 2; i &lt;= n; i++) {\n    // 递推计算\n    a[i] = (a[i - 1] + a[i - 2]) % 1000000007;\n  }\n  return a[n];\n}\n</code></pre> <h4>该算法的时间复杂度是多少呢？</h4> <ul> <li><div class="question-choice" data-right></div> <span class="latex">A. \\Theta(n)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">B. \\Theta(n^2)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">C. \\Theta(2^n)</span></li> <li><div class="question-choice" data-wrong></div> <span class="latex">D. \\Theta((\\frac{1+\\sqrt5}{2})^n)</span></li> </ul> <aside class="notes"> 现在我们来思考一下，采用递推算法实现斐波那契数列的时间复杂度是多少呢？ </aside> <hr> <pre><code data-line-numbers="1-12" data-id="code1" class="language-js">function fib(n) {\n  let a = [];\n  // 初始已知值\n  a[0] = 0;\n  a[1] = 1;\n\n  for (let i = 2; i &lt;= n; i++) {\n    // 递推计算\n    a[i] = (a[i - 1] + a[i - 2]) % 1000000007;\n  }\n  return a[n];\n}\n</code></pre> <aside class="notes"> 正确答案是$A$，该算法没有包含递归，循环进行了$n-1$次，与n线性相关。时间复杂度记作$\\Theta(n)$。 </aside> <hr> <pre><code data-line-numbers="1-12" data-id="code1" class="language-js">function fib(n) {\n  let a = [];\n  // 初始已知值\n  a[0] = 0;\n  a[1] = 1;\n\n  for (let i = 2; i &lt;= n; i++) {\n    // 递推计算\n    a[i] = (a[i - 1] + a[i - 2]) % 1000000007;\n  }\n  return a[n];\n}\n</code></pre> <aside class="notes"> 我们可以注意到，上述算法中，对于计算下一个值，有用的仅仅是最近的2个值，因此之前的值没有必要长期保存。因此我们可以采用不断替换最近2个值的方法，有效的降低问题的空间复杂度： </aside> <hr> <pre><code data-line-numbers="1-15|5-7|8-14|1-15" data-id="code2" class="language-js">function fib(n) {\n  if (n === 0) {\n    return 0;\n  }\n  // 记录最近的两个值\n  let a = 0,\n    b = 1;\n  for (let i = 2; i &lt;= n; i++) {\n    // 下一个值\n    const next = (a + b) % 1000000007;\n    // 滚动\n    a = b;\n    b = next;\n  }\n  return b;\n}\n</code></pre> <aside class="notes"> 在这段代码里，我们只用两个变量来记录最近的两个值。 每次循环过程中，计算出下一个值，然后滚动替换最近的两个值。 这样尽管时间复杂度仍未\\Theta(n)，但空间复杂度有效的降低到了\\Theta(1) </aside> <hr> <blockquote> <p>斐波那契问题的<span class="latex">\\Theta(lgn)</span>求解方法，看<a href="/404.html">这里</a>。</p> </blockquote> <blockquote> <p>母函数求解斐波那契数列通项公式方法，看<a href="/404.html">这里</a>。</p> </blockquote> <aside class="notes"> 值得一提的是除了递归和递推以外，还有其它求解递归定义函数的方法。 <p>例如分治法或矩阵求幂的方法求解斐波那契数列可以达到\\Theta(lgn)的时间复杂度，而组合数学中的母函数方法还可以直接得到它的通项公式。想深入了解的同学可以点击上方链接进一步了解。</p> </aside> <hr> <h2>应用题</h2> <ol> <li class="fragment">抽象问题，定义函数，明确参数和值的含义</li> <li class="fragment">列出可直接求解的函数值</li> <li class="fragment">列出递推公式</li> </ol> <aside class="notes"> 在解决实际问题时，递推算法的设计过程也通常分为以下三个步骤 首先是抽象问题，定义函数，明确函数的参数和值的含义 然后列出可直接求解的函数值 最后列出递推公式。接下来我们来看几道例题。 </aside> <hr> <h2>走台阶问题</h2> <p>一段楼梯共有 N 级台阶，每次可以走一级、走两级、或者走三级，请问总计有多少种不同的走法？</p> <div class="r-stack"> <div class="fragment fade-out" data-fragment-index="12"> <div class="fragment latex" style="font-size:.7em" data-fragment-index="1"> F(n)= \\begin{cases} \\htmlData{class=fragment, fragment-index=2}{1}& \\htmlData{class=fragment, fragment-index=2}{\\text{n = 1}} \\\\ \\htmlData{class=fragment, fragment-index=3}{F(n-1)+} \\htmlData{class=fragment, fragment-index=4}{1 = 2}& \\htmlData{class=fragment, fragment-index=3}{\\text{n = 2}} \\\\ \\htmlData{class=fragment, fragment-index=5}{F(n-1)+} \\htmlData{class=fragment, fragment-index=6}{F(n-2)+} \\htmlData{class=fragment, fragment-index=7}{1 = 4}& \\htmlData{class=fragment, fragment-index=5}{\\text{n = 3}} \\\\ \\htmlData{class=fragment, fragment-index=8}{F(n-1)+} \\htmlData{class=fragment, fragment-index=9}{F(n-2)+} \\htmlData{class=fragment, fragment-index=10}{F(n-3)}& \\htmlData{class=fragment, fragment-index=8}{\\text{n > 3}} \\\\ \\end{cases} </div> </div> <div class="fragment latex" style="font-size:.7em" data-fragment-index="12"> F(n)= \\begin{cases} \\htmlData{class=fragment, fragment-index=13}{0}& \\htmlData{class=fragment, fragment-index=13}{n \\lt 0} \\\\ \\htmlData{class=fragment, fragment-index=14}{1}& \\htmlData{class=fragment, fragment-index=14}{n = 0} \\\\ \\htmlData{class=fragment, fragment-index=18}{F(n-1)+} \\htmlData{class=fragment, fragment-index=18}{F(n-2)+} \\htmlData{class=fragment, fragment-index=18}{F(n-3)}& \\htmlData{class=fragment, fragment-index=18}{n \\gt 0} \\\\ \\end{cases} </div> </div> <aside class="notes"> 读题 设F(n)为走到第n级台阶的总方法数 显然只有一级台阶时只有一种走法。 只有两级台阶时，我们可以从上一级走一级到达， 也可以从起点直接一次走两级到达。 有三级台阶时，我们可以从上一级到达 或者从两级之前一次走两级到达 或者从起点直接到达。 当超过三级台阶时，我们一样可以从上一级到达 或者从两级之前一次走两级到达 或者从三级之前一次走三级到达 <p>我们还可以换一种方法来理解。 我们认为没有任何走法可以走到起点之前，所以当 n&lt;0 时，F(n)为 0 但是从起点开始是可能的，而且抵达起点本身没有多种方法，所以当 n=0 时，F(n)=1 其它的情况，我们都可以用一样的递推公式来描述。因为 F(-1)和 F(-2)都等于 0，所以这个公式和之前的公式是完全等价的。</p> <p>注意在将上述递归函数转化为递推实现时，没有必要求解不合法的值，可以在取<span class="latex">F(n)</span>时，如果参数不合法，则跳过该项。</p> </aside> <hr> <h2>约瑟夫环问题</h2> <p>N 个人排成一圈，从第一个人开始按 1、2、3……K 的顺序循环报数，报到 K 的人出列，请问最后剩下的人是最开始队伍中的第几个人？</p> <div class="latex fragment" data-fragment-index="0"> 假设K=3, N=8 </div> <div class="r-stack"> <div class="fragment fade-out" data-fragment-index="2"> <div class="latex fragment" data-fragment-index="1"> 0,1,2,3,4,5,6,7 </div> </div> <div class="fragment fade-out" data-fragment-index="4"> <div class="latex fragment" data-fragment-index="2"> 5,6,-,0,1,2, \\htmlData{class=fragment highlight-red, fragment-index=3}{3} ,4 </div> </div> <div class="latex fragment" data-fragment-index="4"> \\textcolor{green}0,\\textcolor{green}1,\\textcolor{green}2,3,4,5,\\textcolor{red}6,7 </div> </div> <div class="latex fragment fade-down" data-fragment-index="5"> 5,6,-,0,1,2,\\textcolor{red}{3},4 </div> <aside class="notes"> 我们来观察下K=3, N=8的情况 首先所有人站成一排，每个人都有一个编号。我们这里编号从0开始。 当第一次有人出列之后，剩下的人我们可以得到一批新的编号，并且问题变成了N-1个人的问题。 假设我们已经知道了K=3, N=7的解是3 那么回到第一次报数之前，这个人的编号是多少呢？我们可以看到，这时候相当于需要先加回一个人，然后从这个人开始倒着从K数到1 我们把N个人的问题和N-1个人的问题对照起来，就可以得出公式，F(N-1)+K。需要注意到F(N-1)+K有可能比N大，意味着要从圈头继续数，所以我们可以把结果模N，取余数 </aside> <hr> <h2>约瑟夫环问题</h2> <p>N 个人排成一圈，从第一个人开始按 1、2、3……K 的顺序报数，报到 K 的人出列，请问最后剩下的人是最开始队伍中的第几个人？</p> <p class="latex">F(n)=\\begin{cases} 0&amp;\\text(n=1)\\\\ (F(n-1)+K)\\ mod\\ n&amp;\\text(n&gt;1)\\\\ \\end{cases} \\\\ 输出F(N)+1 </p> <blockquote> <p>解题十分钟系列：<a href="https://www.bilibili.com/video/BV1hK4y1s7Ln?p=2">约瑟夫环</a> </p> </blockquote> <aside class="notes"> 所以可以写出这个公式。只剩下一个人时，他就是胜利者。否则的话，序号总是增加K，然后关于总人数取模。采用递推方法求得$F(N)$，然后$F(N)+1$即为问题的解。 约瑟夫环还是练习数据结构的好问题。想看更完整的介绍、以及了解约瑟夫环更低复杂度的计算方法,可以点击上方链接，查看解题十分钟的视频节目。 </aside> <hr> <h2>路线统计</h2> <p>在一个<span class="latex">N\\times M</span>地图中，每一个格子可能是障碍物或可通行的，只允许向右和向下移动，问从左上角到右下角，共计有多少种不同的走法？</p> <pre><code class="language-text">4 4\n0 0 0 0\n1 0 0 0\n0 0 1 0\n0 0 0 0\n</code></pre> <aside class="notes"> 读题 </aside> <hr> <h2>路线统计</h2> <div class="latex" style="font-size:.8em"> F(x,y)=\\begin{cases} \\htmlData{class=fragment, fragment-index=2}{0}& \\htmlData{class=fragment, fragment-index=2}{x \\lt 0\\lor y \\lt 0} \\\\ \\htmlData{class=fragment, fragment-index=3}{0}& \\htmlData{class=fragment, fragment-index=3}{G(x,y)=1} \\\\ \\htmlData{class=fragment, fragment-index=4}{1}& \\htmlData{class=fragment, fragment-index=4}{x=y=0} \\\\ \\htmlData{class=fragment, fragment-index=6}{F(x-1,y)+} \\htmlData{class=fragment, fragment-index=7}{F(x,y-1)}& \\htmlData{class=fragment, fragment-index=5}{else} \\\\ \\end{cases} </div> <aside class="notes"> 因为只允许向右和向下移动，所以我们可以按照顺序递推求解，我们来列一下递推公式。 x&lt;0或y&lt;0，我们认为超出了边界，不合法，对于计数来说就是返回0。 我们用G(x,y)表示输入的地图。那么如果地图上的对应格为1，说明不可通行，从该格经过的所有组合数也是0。 在起点，到达起点只有一种方法，就是游戏一开始就到起点了。 那么所有其他的格子，只有两种可能性 从左方走过来 或者从上方走过来。那么这就是我们完整的递推式。需要特别注意的一点是，如果状态不能按顺序归纳，譬如可以上下左右四个方向移动，那么是不能用递推方法求解的。我们这题可以用递推，前提是题目规定了只能往右或者往下移动。 </aside> <hr> <h2>涂色问题</h2> <p>用<span class="latex">K</span>种不同的颜色涂<span class="latex">N</span>边形的<span class="latex">N</span>个顶点，要求每点染一种颜色，相邻的两点不能是相同的颜色，请问总计有多少种染法？</p> <aside class="notes"> 有些问题本身没法直接描述成一个可以递推的函数，因此我们需要另外建立一个辅助的函数，通过它间接求出问题的解。 读题。 </aside> <hr> <h2>涂色问题</h2> <p>用<span class="latex">K</span>种不同的颜色涂<span class="latex">N</span>边形的<span class="latex">N</span>个顶点，要求每点染一种颜色，相邻的两点不能是相同的颜色，请问总计有多少种染法？</p> <p><img src="./images/color.png" alt="示例"> </p> <aside class="notes"> 相邻的两点不能是相同的颜色，因此第一个点有$K$种涂法，后续每个点（与之前不同）有$K-1$种，但麻烦的问题在于最后一个顶点也要求和第一个顶点涂法不同，但我们不能确定最后一个顶点是$K-1$种还是$K-2$种涂法。 <p>但是我们可以迂回解决这个问题：如果不限制最后一个点和第一个顶点是否相同颜色，多出的所有组合数，都是最后一个点和第一个顶点颜色相同的情况，并且该颜色和第二个点、倒数第二个点均不同。如果我们将这两个颜色相同的点合并为一个点，那么恰好等同于<span class="latex">N-1</span>边形所有符合要求的所有组合。</p> </aside> <hr> <h2>涂色问题</h2> <p>用<span class="latex">K</span>种不同的颜色涂<span class="latex">N</span>边形的<span class="latex">N</span>个顶点，要求每点染一种颜色，相邻的两点不能是相同的颜色，请问总计有多少种染法？</p> <p class="latex">G(n)=\\begin{cases} K&amp;\\text(n=1)\\\\ G(n-1)*(K-1)&amp;\\text(n \\gt 1)\\\\ \\end{cases}\\\\ \\htmlData{class=fragment, fragment-index=2}{ F(n)=\\begin{cases} G(n)&amp;\\text(n\\le 2)\\\\ G(n)-F(n-1)&amp;\\text(n \\gt 2) \\end{cases} } </p> <aside class="notes"> 我们把不限制最后一个点和第一个点是否颜色相同的函数记作G(n) 那么F(n)就等于G(n)，减去合并了一个顶点的，也就是F(n-1)的组合数。 注意当n=1和2时，是不需要去减的。 虽然$G(n)$是一个等比数列，在数学上很容易写出一个通项公式，但是在算法实现上，反而递推的版本更容易达到整体$\\Theta (n)$的时间复杂度。 </aside> <hr> <h2>涂色问题</h2> <div class="r-stack fragment" data-fragment-index="0"> <div class="latex fragment fade-out" style="font-size:.7em" data-fragment-index="6"> 最后一个点与第一个点颜色不同的组合数：\\\\ F(n)=\\begin{cases} \\htmlData{class=fragment, fragment-index=1}{0} & \\htmlData{class=fragment, fragment-index=1}{n=1} \\\\ \\htmlData{class=fragment, fragment-index=4}{G(n-1)*(K-1) +} \\htmlData{class=fragment, fragment-index=5}{F(n-1)*(K-2)} & \\htmlData{class=fragment, fragment-index=3}{n>1} \\\\ \\end{cases}\\\\ 最后一个点与第一个点颜色相同的组合数：\\\\ G(n)=\\begin{cases} \\htmlData{class=fragment, fragment-index=1}{K} & \\htmlData{class=fragment, fragment-index=1}{n=1} \\\\ \\htmlData{class=fragment, fragment-index=2}{F(n-1)} & \\htmlData{class=fragment, fragment-index=2}{n>1} \\\\ \\end{cases}\\\\ </div> <div class="fragment latex" style="font-size:.7em" data-fragment-index="6"> F(i)=\\begin{cases} 0 & i=1 \\\\ K*(K-1) & i=2 \\\\ F(i-2)*(K-1) + F(i-1)*(K-2)& i>1\\\\ \\end{cases}\\\\ </div> </div> <aside class="notes"> 还可以换一种方法来思考， 第一个点有$K$种涂法，之后按顺序涂每个点，都可能有两种情况：与第一个点颜色不同，或与第一个点颜色相同。我们可设有n个点时，最后一个点与第一个点颜色不同的组合数为F(n)，最后一个点与第一个点颜色相同的组合数为G(n) 一个点的时候，它一定和自己颜色相同，所以 G(1)=K, F(1)= 0 如果超过一个点，那么它如果和第一个点相同，那么它的上一个点和它不同，也就和第一个点必定不同。 那么如果最后一个点和第一个点颜色不同呢，那么上一个点两种情况都有可能。 上一个点和第一个点颜色相同，那么这个点剩下的 K-1 个颜色都可以选择。 上一个点和第一个点颜色不同，这个点有两个颜色不能选，只能选 K-2 种颜色。 我们最后还可以把 G(i)代入到 F(i)里，最后得到这样的公式。这个公式不但可以应用递推法求解，也可以应用矩阵法或者母函数法进行求解。但是需要注意的是我们这里F(1)为0，因为我们这里定义的是最后一个点与第一个点颜色不同的组合数量，所以对原始的问题，我们需要对1单独判断，返回K，所有大于1的n，都可以返回F(n)作为问题的解。 </aside> <hr> <h2>整数划分</h2> <p>将正整数<span class="latex">N</span>划分成至少两个正整数的和。求解所有本质不同的划分的组合总数，顺序不同的解只能算作一个解。</p> <p>例如<span class="latex">N=4</span>时有 4 种划分：</p> <p class="latex">4=1+1+1+1\\\\ 4=1+1+2\\\\ 4=1+3\\\\ 4=2+2\\\\ </p> <aside class="notes"> 读题 </aside> <hr> <h2>整数划分</h2> <p>将正整数<span class="latex">N</span>划分成至少两个正整数的和。求解所有本质不同的划分的组合总数，顺序不同的解只能算作一个解。</p> <p>例如<span class="latex">N=4</span>时有 4 种划分：</p> <p class="latex">4=1+1+1+1\\\\ 4=1+1+2\\\\ 4=1+3\\\\ 4=2+2\\\\ </p> <aside class="notes"> 有些问题题目中没有包含所有的参数，我们需要为函数补充一个隐含的参数才能完成递推过程. 这道题显然可以使用深度优先求解，但这样复杂度至少为指数级。 实际上，我们要求解的是本质不同的组合总数，换句话说，必须保证划分的顺序。这样我们无法直接对$F(n)$进行递推，因为我们不知道之前的解中最大的一个数是多少。但我们可以引入新的参数$j$： </aside> <hr> <h2>整数划分</h2> <p class="latex">F(n,j)=\\begin{cases} \\htmlData{class=fragment, fragment-index=1}{1}&amp; \\htmlData{class=fragment, fragment-index=1}{\\text{n=j}} \\\\ \\htmlData{class=fragment, fragment-index=2}{0}&amp; \\htmlData{class=fragment, fragment-index=2}{\\text{n&lt;j}} \\\\ \\htmlData{class=fragment, fragment-index=3}{ \\sum\\limits_{i=1}^{j}f(n-j, i) }&amp; \\htmlData{class=fragment, fragment-index=3}{\\text{n&gt;j}} \\\\ \\end{cases} \\\\ \\htmlData{class=fragment, fragment-index=10}{ G(n)=\\sum\\limits_{i=1}^{n-1}f(n,i) } </p> <aside class="notes"> 定义$F(n,j)$表示对n的所有划分中，**最大一份恰好为$j$的方案**，那么剩下的部分就可以采用所有$\\le j$的划分，然后就可以写出递推式 如果n=j，那么只有一种组合。 如果n&lt;j，那么已经无法划分出j了，组合数为0。 其余的情况，我们可以对剩下的部分也就是n-j，依次尝试最大值从1到j的所有划分 最后回到问题本身，问题要求至少分成两个数，所以我们可以设G(n)为问题的解，那么最大一个数最多只能分到n-1 </aside> <hr> <h2>括号生成</h2> <p>有 N 对括号，问有多少种有效的括号组合？有效是指每对括号都是左括号在左、右括号在右。</p> <pre><code class="language-text">N=3时有5种组合：\n((()))\n(()())\n(())()\n()(())\n()()()\n</code></pre> <hr> <h2>括号生成</h2> <p>有 N 对括号，问有多少种有效的括号组合？有效是指每对括号都是左括号在左、右括号在右。</p> <pre><code class="language-text">N=3时有5种组合：\n((()))\n(()())\n(())()\n()(())\n()()()\n</code></pre> <aside class="notes"> 我们可以看出，合法组合的任意前缀，都有左括号数量>=右括号数量（右括号一旦多余左括号，就不能完成匹配）。反之，如果一个组合的任意前缀都有左括号数量>=右括号数量，那么该组合必定是合法的。 </aside> <hr> <h2>括号生成</h2> <div class="latex" style="font-size:.8em"> F(i,j)=\\begin{cases} \\htmlData{class=fragment, fragment-index=1}{0}& \\htmlData{class=fragment, fragment-index=1}{(i \\le j \\lor j \\le 0)} \\\\ \\htmlData{class=fragment, fragment-index=2}{1}& \\htmlData{class=fragment, fragment-index=2}{(i=0 \\land j=0)} \\\\ \\htmlData{class=fragment, fragment-index=3}{F(i-1,j)+F(i,j-1)} & \\htmlData{class=fragment, fragment-index=3}{(else)} \\\\ \\end{cases} </div> <aside class="notes"> 因此我们可以规定$F(i,j)$为i个左括号和j个右括号组成的所有合法组合总数，分为三种情况讨论： <ul> <li><span class="latex">i&lt;j 或者 j&lt;0</span>时，一定不合法。</li> <li><span class="latex">i=0 且 j=0</span>时，已经填完所有的括号，因此记作一种合法组合。</li> <li>其余情况，最后位置可以选择左括号或右括号。选择之后有可能导致剩下的数目不合法，此时<span class="latex">F(i-1,j)</span>或<span class="latex">F(i,j-1)</span>为 0，无需额外处理。</li> </ul> </aside> <hr> <h2>括号生成</h2> <div class="r-stack"> <div> <code class="fragment fade-out" data-fragment-index="4"> <span class="fragment highlight-red" data-fragment-index="1">(</span><span class="fragment highlight-current-green" data-fragment-index="2">(())</span><span class="fragment highlight-red" data-fragment-index="1">)</span> <br/> <span class="fragment highlight-red" data-fragment-index="1">(</span><span class="fragment highlight-current-green" data-fragment-index="2">()()</span><span class="fragment highlight-red" data-fragment-index="1">)</span> <br/> <span class="fragment highlight-red" data-fragment-index="1">(</span><span class="fragment highlight-current-green" data-fragment-index="2">()</span><span class="fragment highlight-red" data-fragment-index="1">)</span><span class="fragment highlight-current-green" data-fragment-index="3">()</span> <br/> <span class="fragment highlight-red" data-fragment-index="1">()</span><span class="fragment highlight-current-green" data-fragment-index="3">(())</span> <br/> <span class="fragment highlight-red" data-fragment-index="1">()</span><span class="fragment highlight-current-green" data-fragment-index="3">()()</span> <br/> </code> </div> <div class="latex fragment" data-fragment-index="4"> F(n)=\\begin{cases} 1&(n=0)\\\\ \\sum\\limits_{i=0}^{n-1}F(i)*F(n-1-i)&(n>0) \\\\ \\end{cases} </div> </div> <blockquote> <p>解题十分钟系列：<a href="https://www.bilibili.com/video/BV1hK4y1s7Ln?p=1">括号生成</a> </p> </blockquote> <aside class="notes"> 我们还可以换一种思路，考虑第一个左括号，及与其匹配的右括号。 剩下的括号，要么在这对括号内部 要么在这对括号右侧。这时可采用分治法思想，将这对括号内部和右侧的所有组合都可以看做子问题。 设$F(n)$为n对括号的所有合法组合总数，那么可以得到这样的公式。 关于括号组合问题的更多分析，可以看解题十分钟视频，通过变形，还可以得到一个可以在Theta(n)时间内求解的公式。这个组合数也被叫做卡塔兰数。 </aside> <hr> <h2>递推问题的解决过程</h2> <ol> <li class="fragment">明确参数，定义函数</li> <li class="fragment">逆推函数，列出递推公式</li> <li class="fragment">确定可以直接求解的基础函数值</li> </ol> <aside class="notes"> 所以解决一个递推问题至少需要三个过程。 1. **明确参数，定义函数**：参数可能是问题本身的输入，也可能需要引入新的辅助参数。 2. **逆推函数，列出递推公式**：将一个未知状态的解用几个已知状态来描述。应用题常使用分治法。组合计数类问题常需要应用加法原理、乘法原理等。 3. **确定可直接求解的基础函数值**：包括“不合法情形”和“初始情形”等。 </aside> <hr> <h2>适用递推算法的前提</h2> <ol> <li class="fragment">参数必须能描述完整的问题状态</li> <li class="fragment">递推公式必须能按顺序求解</li> <li class="fragment">参数取值范围必须有限，不涉及连续参数、无穷参数</li> </ol> <aside class="notes"> 还要特别注意，有些问题不适用递推算法 1. **参数必须能描述完整的问题状态**。如果参数不能完整描述状态，就极易得出错误的递推公式。需要多做练习。例如我们上面的整数划分问题，如果不把最大值j当做参数的一部分，就很容易得到一个错误的公式。 2. **递推公式必须能按顺序求解**：如果状态的变化路径中存在环，那么可能要应用一些搜索算法(如广度优先搜索、深度优先搜索、A*等)。如果不存在环，但不能按顺序归纳，那么有可能使用带缓存的递归来替代递推会使得编码更加容易。例如我们上面聊到的路线统计问题，如果可以朝四个方向移动，那么就不能用递推 3. **参数取值范围必须有限，不涉及连续参数、无穷参数**：如果参数的取值范围可能有无穷多个，不论是连续域、范围过大，还是其它涉及到无穷多种参数等情况，都必须先用数学方法将参数取值范围确定到有限个数之内才能应用递推算法。 </aside> <hr> <p><img src="./images/ending.png" alt="Ending"></p> <aside class="notes"> 今天的课程就到这里结束，谢谢大家。 </aside> '},9883:(a,n,e)=>{"use strict";var s=e(3379),t=e.n(s),l=e(7651);t()(l.Z,{insert:"head",singleton:!1}),l.Z.locals},9178:(a,n,e)=>{"use strict";var s=e(4096),t=e(9151);e(9883),window.addEventListener("DOMContentLoaded",(function(){(0,s._j)(t.Z,!1)}))}},a=>{"use strict";a.O(0,[96],(()=>(9178,a(a.s=9178)))),a.O()}]);